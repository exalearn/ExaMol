"""Base classes for scoring functions"""
import numpy as np

from examol.store.models import MoleculeRecord


class Scorer:
    """Base class for algorithms which quickly assign a score to a molecule, typically using a machine learning model

    **Using a Scorer**

    Scoring a molecule requires transforming the molecule into a form compatible with a machine learning algorithm,
    then executing inference using the machine learning algorithm.
    We separate these two steps so that the former can run on local resources
    and the latter can run on larger remote resource.
    Running the scorer will then look something like

    .. code-block::
        python

        model = Scorer()
        inputs = model.transform_inputs(records)  # Runs locally, using options of scorer
        model_msg = model.get_state()  # Gets the current copy of the model from disk
        Scorer.score(inputs)  # Can be run remotely


    Training operations are broken into separate operations for similar reasons.
    We separate the training operation from pre-processing inputs and outputs,
    and updating a local copy of the model given the results of training.

    .. code-block: python

        outputs = model.transform_outputs(records)
        update_msg = Scorer.retrain(model_msg, inputs, outputs)  # Run remotely
        model.update(update_msg)

    """

    def transform_inputs(self, record_batch: list[MoleculeRecord]) -> list:
        """Form inputs for the model based on the data in a molecule record

        Args:
            record_batch: List of records to pre-process
        Returns:
            List of inputs ready for :meth:`score` or :meth:`retrain`
        """
        raise NotImplementedError()

    def transform_outputs(self, records: list[MoleculeRecord]) -> np.ndarray:
        """Gather the target outputs of the model

        Args:
            records: List of records from which to extract outputs
        Returns:
            List of inputs ready for the
        """
        raise NotImplementedError()

    def get_model_state(self) -> object:
        """Get the model state as a serializable object

        Returns:
            Get the model state as a object which can be serialized
        """

    @staticmethod
    def score(model_msg: object, inputs: list, **kwargs) -> np.ndarray:
        """Assign a score to molecules

        Args:
            model_msg: Model to be used to score inputs
            inputs: Batch of inputs ready for the model, as generated by
        Returns:
            The scores to a set of records
        """
        raise NotImplementedError()

    @staticmethod
    def retrain(model_msg: object, inputs: list, outputs: list, **kwargs) -> object:
        """Retrain the scorer based on new training records

        Args:
            model_msg: Model to be retrained
            inputs: Training set inputs
            outputs: Training Set outputs
        Returns:
            Message defining how to update the model
        """

    def update(self, update_msg: object):
        """Update this local copy of a model

        Args:
            update_msg: Update for the model
        """
        raise NotImplementedError()
